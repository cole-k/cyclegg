/Users/pro/.cargo/bin/cargo run --color=always --package cyclegg --bin cyclegg --release -- examples/clam_no_lemmas.ceg -d 100000 -t 60 -r
warning: cyclegg v0.1.0 (/Users/pro/Desktop/work/2024S/cyclegg) ignoring invalid dependency `clippy` which is missing a lib target
warning: unused import: `NodeIndex`
 --> src/goal.rs:7:43
  |
7 | use petgraph::matrix_graph::{MatrixGraph, NodeIndex};
  |                                           ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `Ordering`, `Reverse`
 --> src/goal.rs:8:16
  |
8 | use std::cmp::{Ordering, Reverse};
  |                ^^^^^^^^  ^^^^^^^

warning: unused import: `BinaryHeap`
 --> src/goal.rs:9:43
  |
9 | use std::collections::{BTreeSet, HashMap, BinaryHeap, HashSet};
  |                                           ^^^^^^^^^^

warning: unused import: `print_cvec`
  --> src/goal.rs:17:91
   |
17 | use crate::analysis::{CycleggAnalysis, CanonicalFormAnalysis, CanonicalForm, cvecs_equal, print_cvec, CvecAnalysis, Cvec};
   |                                                                                           ^^^^^^^^^^

warning: unused imports: `CvecAnalysis`, `print_cvec`
 --> src/utils.rs:7:23
  |
7 | use crate::analysis::{CvecAnalysis, CycleggAnalysis, print_cvec};
  |                       ^^^^^^^^^^^^                   ^^^^^^^^^^

warning: unused import: `itertools::Unique`
 --> src/goal_graph.rs:3:5
  |
3 | use itertools::Unique;
  |     ^^^^^^^^^^^^^^^^^

warning: unused variable: `f`
   --> src/ast.rs:398:30
    |
398 | pub fn get_vars<F>(e: &Expr, f: F) -> BTreeSet<Symbol>
    |                              ^ help: if this is intentional, prefix it with an underscore: `_f`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `args`
   --> src/explain.rs:188:7
    |
188 |   let args: Vec<(Symbol, Type)> = params
    |       ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: unused variable: `lemma_number`
   --> src/explain.rs:218:8
    |
218 |   for (lemma_number, lemma_proof) in state.lemma_proofs.iter() {
    |        ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_lemma_number`

warning: unused variable: `eclass`
   --> src/goal.rs:157:32
    |
157 |   fn check(&self, egraph: &Eg, eclass: Id, subst: &Subst) -> bool {
    |                                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_eclass`

warning: unused variable: `subst`
   --> src/goal.rs:214:77
    |
214 |   fn check(&self, egraph: &EGraph<SymbolLang, CycleggAnalysis>, eclass: Id, subst: &Subst) -> bool {
    |                                                                             ^^^^^ help: if this is intentional, prefix it with an underscore: `_subst`

warning: unused variable: `pre_expr`
    --> src/goal.rs:1246:15
     |
1246 |       let mut pre_expr = self.full_expr.clone();
     |               ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pre_expr`

warning: variable does not need to be mutable
    --> src/goal.rs:1246:11
     |
1246 |       let mut pre_expr = self.full_expr.clone();
     |           ----^^^^^^^^
     |           |
     |           help: remove this `mut`
     |
     = note: `#[warn(unused_mut)]` on by default

warning: variable `i` is assigned to, but never used
    --> src/goal.rs:2354:13
     |
2354 |     let mut i = 0;
     |             ^
     |
     = note: consider using `_i` instead

warning: unused variable: `goals`
    --> src/goal.rs:2800:11
     |
2800 |       let goals = self.goal_graph.get_lemma(0).goals.clone();
     |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_goals`

warning: associated function `make_rewrite` is never used
    --> src/goal.rs:1113:6
     |
579  | impl<'a> Goal<'a> {
     | ----------------- associated function in this implementation
...
1113 |   fn make_rewrite(lhs: Pat, rhs: Pat, cond: Soundness, lemma_name: String) -> (String, Rw) {
     |      ^^^^^^^^^^^^
     |
     = note: `#[warn(dead_code)]` on by default

warning: method `name` is never used
    --> src/goal.rs:2030:6
     |
2029 | impl ProofLeaf {
     | -------------- method in this implementation
2030 |   fn name(&self) -> String {
     |      ^^^^

warning: methods `bulk_compare_lemma` and `build_lemma_graph` are never used
    --> src/goal.rs:2434:6
     |
2337 | impl<'a> ProofState<'a> {
     | ----------------------- methods in this implementation
...
2434 |   fn bulk_compare_lemma<I: IntoIterator<Item = usize>>(&self, lemma: usize, lemmas: I) -> Vec<usize> {
     |      ^^^^^^^^^^^^^^^^^^
...
2474 |   fn build_lemma_graph(&self) -> (Vec<usize>, MatrixGraph<(), (), Directed, Option<()>, usize>) {
     |      ^^^^^^^^^^^^^^^^^

warning: method `re_extract_lemmas` is never used
    --> src/goal.rs:2756:6
     |
2712 | impl GoalLevelPriorityQueue {
     | --------------------------- method in this implementation
...
2756 |   fn re_extract_lemmas<'a>(&mut self, proof_state: &mut ProofState<'a>) {
     |      ^^^^^^^^^^^^^^^^^

warning: field `info` is never read
  --> src/goal_graph.rs:45:5
   |
44 | pub struct GoalNode {
   |            -------- field in this struct
45 |     info: GoalInfo,
   |     ^^^^

warning: field `lemma_id` is never read
  --> src/goal_graph.rs:66:5
   |
64 | pub struct LemmaNode {
   |            --------- field in this struct
65 |     pub goals: Vec<GoalInfo>,
66 |     lemma_id: usize,
   |     ^^^^^^^^

warning: `cyclegg` (bin "cyclegg") generated 21 warnings (run `cargo fix --bin "cyclegg"` to apply 14 suggestions)
    Finished release [optimized] target(s) in 0.06s
     Running `target/release/cyclegg examples/clam_no_lemmas.ceg -d 100000 -t 60 -r`
Proving begin clam_1: (double x) === (plus x x)
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
prove lemma forall x: Nat. (double x) === (plus x x)
prove lemma forall v0: Nat. (S (double v0)) === (plus v0 (S v0))
clam_1 uncyclic: VALID (22 ms)
Proving begin clam_2: (len (append x y)) === (len (append y x))
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: (List a). v1: a. (S (len v0)) === (len (append v0 (Cons v1 Nil)))
new lemma forall x: (List a). y: (List a). (len (append x y)) === (len (append y x))
clam_2 uncyclic: VALID (418 ms)
Proving begin clam_3: (len (append x y)) === (plus (len x) (len y))
new lemma forall x: (List a). y: (List a). (len (append x y)) === (plus (len x) (len y))
clam_3 uncyclic: VALID (12 ms)
Proving begin clam_4: (len (append x x)) === (double (len x))
new lemma forall v0: (List a). v1: (List a). v2: a. (S (len (append v0 v1))) === (len (append v0 (Cons v2 v1)))
prove lemma forall x: (List a). (len (append x x)) === (double (len x))
prove lemma forall v0: (List a). v1: a. (S (double (len v0))) === (len (append v0 (Cons v1 v0)))
clam_4 uncyclic: VALID (243 ms)
Proving begin clam_5: (len (rev x)) === (len x)
new lemma forall v0: (List a). v1: a. (S (len v0)) === (len (append v0 (Cons v1 Nil)))
prove lemma forall x: (List a). (len (rev x)) === (len x)
clam_5 uncyclic: VALID (79 ms)
Proving begin clam_6: (len (rev (append x y))) === (plus (len x) (len y))
new lemma forall v0: (List a). v1: a. (S (len v0)) === (len (append v0 (Cons v1 Nil)))
new lemma forall x: (List a). y: (List a). (len (rev (append x y))) === (plus (len x) (len y))
clam_6 uncyclic: VALID (121 ms)
Proving begin clam_7: (len (qreva x y)) === (plus (len x) (len y))
new lemma forall v0: Nat. v0 === (plus v0 Z)
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus (plus v0 Z) (S v1))
new lemma forall v0: (List a). v1: (List a). (S (plus (len v0) (len v1))) === (plus (len v0) (S (len v1)))
clam_7 uncyclic: TIMEOUT (60141 ms)
Proving begin clam_8: (drop x (drop y z)) === (drop y (drop x z))
new lemma forall v0: Nat. v1: (List a). (drop (S v0) v1) === (drop (S Z) (drop v0 v1))
prove lemma forall x: Nat. y: Nat. z: (List a). (drop x (drop y z)) === (drop y (drop x z))
prove lemma forall v0: Nat. v1: Nat. v2: (List a). (drop v0 (drop v1 v2)) === (drop v1 (drop v0 v2))
clam_8 uncyclic: VALID (143 ms)
Proving begin clam_9: (drop w (drop x (drop y z))) === (drop y (drop x (drop w z)))
new lemma forall v0: Nat. v1: (List a). (drop (S v0) v1) === (drop (S Z) (drop v0 v1))
prove lemma forall v0: Nat. v1: Nat. v2: (List a). (drop v0 (drop v1 v2)) === (drop v1 (drop v0 v2))
clam_9 uncyclic: VALID (180 ms)
Proving begin clam_10: (rev (rev x)) === x
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall x: (List a). (rev (rev x)) === x
clam_10 uncyclic: VALID (127 ms)
Proving begin clam_11: (rev (append (rev x) (rev y))) === (append y x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (rev (rev v0))
new lemma forall v0: (List a). v1: (List a). v2: (List a). (append v0 (append v1 v2)) === (append (append v0 v1) v2)
prove lemma forall v0: (List a). v1: (List a). (append v0 (rev v1)) === (rev (append v1 (rev v0)))
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (append (rev v1) (rev v0)))
clam_11 uncyclic: VALID (43106 ms)
Proving begin clam_12: (qreva x y) === (append (rev x) y)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
prove lemma forall x: (List a). y: (List a). (qreva x y) === (append (rev x) y)
clam_12 uncyclic: VALID (139 ms)
Proving begin clam_13: (half (plus x x)) === x
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
prove lemma forall x: Nat. (half (plus x x)) === x
clam_13 uncyclic: VALID (58 ms)
Proving begin clam_14: (sorted (sort x)) === True
new lemma forall v0: Bool. v0 === (and v0 True)
new lemma forall v0: Nat. v1: Nat. (and (leq v0 v1) True) === (leq v0 v1)
clam_14 uncyclic: TIMEOUT (60059 ms)
Proving begin clam_15: (plus x (S x)) === (S (plus x x))
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
clam_15 uncyclic: VALID (13 ms)
Proving begin clam_16: (even (plus x x)) === True
new lemma forall v0: Bool. v0 === (not (not v0))
new lemma forall v0: Nat. v1: Nat. (S (S (S (plus v0 (S v1))))) === (S (plus v0 (S (S (S v1)))))
prove lemma forall x: Nat. (even (plus x x)) === True
prove lemma forall v0: Nat. (S (plus v0 (S v0))) === (plus v0 (S (S v0)))
prove lemma forall v0: Nat. (even (plus v0 (S v0))) === (not (even (plus v0 (S (S v0)))))
prove lemma forall v0: Nat. (even (plus v0 v0)) === (even (plus v0 (S (S v0))))
prove lemma forall v0: Nat. (even (plus v0 (S (S v0)))) === (not (even (plus v0 (S v0))))
prove lemma forall v0: Nat. True === (even (plus v0 (S (S v0))))
prove lemma forall v0: Nat. (not (even (plus v0 v0))) === (not (even (plus v0 (S (S v0)))))
prove lemma forall v0: Nat. (S (plus v0 (S (S v0)))) === (plus v0 (S (S (S v0))))
prove lemma forall v0: Nat. (even (plus v0 (S v0))) === (even (plus v0 (S (S (S v0)))))
prove lemma forall v0: Nat. (S (S (plus v0 (S v0)))) === (plus v0 (S (S (S v0))))
prove lemma forall v0: Nat. False === (not (even (plus v0 (S (S v0)))))
prove lemma forall v0: Nat. False === (even (plus v0 (S (S (S v0)))))
prove lemma forall v0: Nat. True === (not (even (plus v0 (S (S (S v0))))))
clam_16 uncyclic: VALID (1473 ms)
Proving begin clam_17: (rev (rev (append x y))) === (append (rev (rev x)) (rev (rev y)))
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (rev (rev v0))
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (rev (append v0 v1)))
clam_17 uncyclic: VALID (283 ms)
Proving begin clam_18: (rev (append (rev x) y)) === (append (rev y) x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
new lemma forall v0: (List a). v0 === (rev (rev v0))
new lemma forall v0: (List a). v1: (List a). v2: (List a). (append v0 (append v1 v2)) === (append (append v0 v1) v2)
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (append (rev v1) (rev v0)))
prove lemma forall v0: (List a). v1: (List a). (append v0 (rev v1)) === (rev (append v1 (rev v0)))
clam_18 uncyclic: VALID (43883 ms)
Proving begin clam_19: (append (rev (rev x)) y) === (rev (rev (append x y)))
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (append (rev (rev v0)) v1)
prove lemma forall v0: (List a). v0 === (rev (rev v0))
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (rev (append v0 v1)))
clam_19 uncyclic: VALID (396 ms)
Proving begin clam_20: (even (len (append x x))) === True
new lemma forall v0: Bool. v0 === (not (not v0))
clam_20 uncyclic: TIMEOUT (60054 ms)
Proving begin clam_21: (rotate (len x) (append x y)) === (append y x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
clam_21 uncyclic: TIMEOUT (60120 ms)
Proving begin clam_22: (even (len (append x y))) === (even (len (append y x)))
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: (List a). v1: a. (S (len v0)) === (len (append v0 (Cons v1 Nil)))
new lemma forall v0: (List a). v1: (List a). (len (append v0 v1)) === (len (append v1 v0))
clam_22 uncyclic: VALID (1035 ms)
Proving begin clam_23: (half (len (append x y))) === (half (len (append y x)))
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: (List a). v1: a. (S (len v0)) === (len (append v0 (Cons v1 Nil)))
new lemma forall v0: (List a). v1: (List a). (len (append v0 v1)) === (len (append v1 v0))
clam_23 uncyclic: VALID (1020 ms)
Proving begin clam_24: (even (plus x y)) === (even (plus y x))
new lemma forall v0: Nat. v0 === (plus v0 Z)
new lemma forall v0: Nat. (S v0) === (plus v0 (S Z))
new lemma forall v0: Nat. v1: Nat. (plus v0 v1) === (plus v1 v0)
clam_24 uncyclic: VALID (180 ms)
Proving begin clam_25: (even (len (append x y))) === (even (plus (len x) (len y)))
new lemma forall v0: (List a). v1: (List a). (len (append v0 v1)) === (plus (len v0) (len v1))
clam_25 uncyclic: VALID (32 ms)
Proving begin clam_26: (half (plus x y)) === (half (plus y x))
new lemma forall v0: Nat. v0 === (plus v0 Z)
new lemma forall v0: Nat. (S v0) === (plus v0 (S Z))
new lemma forall v0: Nat. v1: Nat. (plus v0 v1) === (plus v1 v0)
clam_26 uncyclic: VALID (183 ms)
Proving begin clam_27: (rev x) === (qreva x Nil)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
prove lemma forall v0: (List a). v1: (List a). (append (qreva v0 Nil) v1) === (qreva v0 v1)
prove lemma forall v0: (List a). v1: (List a). (append (rev v0) v1) === (qreva v0 v1)
prove lemma forall v0: (List a). v1: a. v2: (List a). (append (qreva v0 (Cons v1 Nil)) v2) === (qreva v0 (Cons v1 v2))
prove lemma forall x: (List a). (rev x) === (qreva x Nil)
clam_27 uncyclic: VALID (391 ms)
Proving begin clam_28: (revflat x) === (qrevaflat x Nil)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
new lemma forall v0: (List a). v1: a. v2: (List a). v3: (List a). (append v0 (Cons v1 (append v2 v3))) === (append (append v0 (Cons v1 v2)) v3)
prove lemma forall v0: (Tree a). v1: (List a). (append (qrevaflat v0 Nil) v1) === (qrevaflat v0 v1)
prove lemma forall v0: (Tree a). v1: a. v2: (List a). (append (revflat v0) (Cons v1 v2)) === (qrevaflat v0 (Cons v1 v2))
prove lemma forall v0: (Tree a). v1: (List a). (append (revflat v0) v1) === (qrevaflat v0 v1)
prove lemma forall v0: (Tree a). v1: a. v2: (List a). (append (qrevaflat v0 Nil) (Cons v1 v2)) === (qrevaflat v0 (Cons v1 v2))
prove lemma forall x: (Tree a). (revflat x) === (qrevaflat x Nil)
clam_28 uncyclic: VALID (5973 ms)
Proving begin clam_29: (rev (qreva x Nil)) === x
new lemma forall v0: a. v1: (List a). v2: (List a). (Cons v0 (qreva v1 v2)) === (qreva (append v1 (Cons v0 Nil)) v2)
prove lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (qreva (rev v1) (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (qreva (rev v0) Nil)
prove lemma forall v0: (List a). v1: (List a). (qreva v0 v1) === (qreva (rev (qreva v0 v1)) Nil)
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (qreva (append (rev v1) (Cons v0 Nil)) Nil)
prove lemma forall x: (List a). (rev (qreva x Nil)) === x
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (rev (qreva v1 (Cons v0 Nil)))
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (rev (qreva (rev (qreva v1 Nil)) (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (rev (qreva v0 Nil))
prove lemma forall v0: (List a). v1: (List a). (rev (qreva v0 v1)) === (rev (qreva (rev (qreva v0 Nil)) v1))
prove lemma forall v0: (List a). v1: (List a). (qreva v0 v1) === (qreva (rev (qreva v0 Nil)) v1)
clam_29 uncyclic: VALID (1815 ms)
Proving begin clam_30: (rev (append (rev x) Nil)) === x
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall x: (List a). (rev (append (rev x) Nil)) === x
clam_30 uncyclic: VALID (350 ms)
Proving begin clam_31: (qreva (qreva x Nil) Nil) === x
clam_31 uncyclic: TIMEOUT (60025 ms)
Proving begin clam_32: (rotate (len x) x) === x
clam_32 uncyclic: TIMEOUT (60210 ms)
Proving begin clam_33: (fac x) === (qfac x (S Z))
clam_33 uncyclic: INVALID (9 ms)
Proving begin clam_34: (mult x y) === (qmult x y Z)
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
new lemma forall v0: Nat. v1: Nat. v2: Nat. v3: Nat. (S (plus (qmult v0 v1 v2) v3)) === (plus (qmult v0 v1 (S v2)) v3)
new lemma forall v0: Nat. v1: Nat. v2: Nat. v3: Nat. (S (plus (plus (qmult v0 v1 (S v2)) v3) v3)) === (plus (plus (qmult v0 v1 (S (S v2))) v3) v3)
new lemma forall v0: Nat. v1: Nat. v2: Nat. (S (plus (plus (qmult v0 (S v1) v2) v1) v1)) === (plus (plus (qmult v0 (S v1) (S v2)) v1) v1)
new lemma forall v0: Nat. v0 === (plus v0 Z)
new lemma forall v0: Nat. v1: Nat. (plus v0 v1) === (plus v1 v0)
new lemma forall v0: Nat. v1: Nat. v2: Nat. v3: Nat. (plus v0 (qmult v1 v2 v3)) === (qmult v1 v2 (plus v3 v0))
prove lemma forall x: Nat. y: Nat. (mult x y) === (qmult x y Z)
clam_34 uncyclic: VALID (16298 ms)
Proving begin clam_35: (exp x y) === (qexp x y (S Z))
new lemma forall v0: Nat. Z === (mult v0 Z)
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
new lemma forall v0: Nat. v1: Nat. (plus v0 v1) === (plus v1 v0)
new lemma forall v0: Nat. v1: Nat. v2: Nat. (S (plus (plus v0 v1) v2)) === (S (plus (plus v0 v2) v1))
prove lemma forall v0: Nat. v1: Nat. (mult v0 (S v1)) === (plus (mult v0 v1) v0)
clam_35 uncyclic: TIMEOUT (65610 ms)
Proving begin clam_48: (len (sort x)) === (len x)
new lemma forall v0: (List Nat). v1: Nat. (S (len v0)) === (len (insort v1 v0))
prove lemma forall x: (List Nat). (len (sort x)) === (len x)
clam_48 uncyclic: VALID (84 ms)
Proving begin clam_49: (mem x (sort y)) === True ==> (mem x y) === True
clam_49 uncyclic: INVALID (8612 ms)
Proving begin clam_50: (count x (sort y)) === (count x y)
new lemma forall v0: (List Nat). (S (count Z v0)) === (count Z (insort Z v0))
new lemma forall v0: (List Nat). v1: Nat. (count Z v0) === (count Z (insort (S v1) v0))
new lemma forall v0: Nat. v1: (List Nat). (count (S v0) v1) === (count (S v0) (insort Z v1))
clam_50 uncyclic: TIMEOUT (60956 ms)
Proving begin clam_75: (append (rev x) y) === (qreva x y)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
prove lemma forall x: (List a). y: (List a). (append (rev x) y) === (qreva x y)
clam_75 uncyclic: VALID (147 ms)
Proving begin clam_76: (append (revflat x) y) === (qrevaflat x y)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
new lemma forall v0: (List a). v1: a. v2: (List a). v3: (List a). (append v0 (Cons v1 (append v2 v3))) === (append (append v0 (Cons v1 v2)) v3)
prove lemma forall x: (Tree a). y: (List a). (append (revflat x) y) === (qrevaflat x y)
prove lemma forall v0: (Tree a). v1: (List a). (append (revflat v0) v1) === (qrevaflat v0 v1)
clam_76 uncyclic: VALID (1994 ms)
Proving begin clam_77: (rev (qreva x y)) === (append (rev y) x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
clam_77 uncyclic: TIMEOUT (60094 ms)
Proving begin clam_78: (rev (qreva x (rev y))) === (append y x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (rev (rev v0))
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (rev (append (rev v1) (Cons v0 Nil)))
clam_78 uncyclic: TIMEOUT (60030 ms)
Proving begin clam_79: (rev (append (rev x) y)) === (append (rev y) x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
new lemma forall v0: (List a). v0 === (rev (rev v0))
new lemma forall v0: (List a). v1: (List a). v2: (List a). (append v0 (append v1 v2)) === (append (append v0 v1) v2)
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (append (rev v1) (rev v0)))
prove lemma forall v0: (List a). v1: (List a). (append v0 (rev v1)) === (rev (append v1 (rev v0)))
clam_79 uncyclic: VALID (43508 ms)
Proving begin clam_80: (rev (append (rev x) (rev y))) === (append y x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: a. v1: (List a). (Cons v0 (rev v1)) === (rev (append v1 (Cons v0 Nil)))
prove lemma forall v0: (List a). v0 === (rev (rev v0))
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (rev (append (rev v1) (Cons v0 Nil)))
new lemma forall v0: (List a). v1: (List a). v2: (List a). (append v0 (append v1 v2)) === (append (append v0 v1) v2)
prove lemma forall v0: (List a). v1: (List a). (append v0 (rev v1)) === (rev (append v1 (rev v0)))
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (rev (append (rev v1) (rev v0)))
clam_80 uncyclic: VALID (45246 ms)
Proving begin clam_81: (qreva (qreva x y) Nil) === (append (rev y) x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
clam_81 uncyclic: TIMEOUT (60144 ms)
Proving begin clam_82: (qreva (qreva x (rev y)) Nil) === (append y x)
new lemma forall v0: a. v1: (List a). v2: (List a). (Cons v0 (qreva v1 v2)) === (qreva (append v1 (Cons v0 Nil)) v2)
new lemma forall v0: (List a). v1: a. v2: (List a). (append v0 (Cons v1 v2)) === (append (append v0 (Cons v1 Nil)) v2)
prove lemma forall v0: (List a). v1: (List a). (append (qreva v0 Nil) v1) === (qreva v0 v1)
prove lemma forall v0: (List a). v1: a. v2: (List a). (append (qreva v0 (Cons v1 Nil)) v2) === (qreva v0 (Cons v1 v2))
prove lemma forall v0: a. v1: (List a). (Cons v0 (qreva v1 Nil)) === (qreva (qreva (qreva v1 Nil) (Cons v0 Nil)) Nil)
prove lemma forall v0: a. v1: (List a). (Cons v0 v1) === (qreva (qreva v1 (Cons v0 Nil)) Nil)
prove lemma forall v0: (List a). v1: (List a). (append v0 v1) === (qreva (qreva v0 Nil) v1)
prove lemma forall v0: (List a). v1: a. (append v0 (Cons v1 Nil)) === (qreva (qreva v0 Nil) (Cons v1 Nil))
prove lemma forall v0: a. v1: (List a). v2: (List a). (Cons v0 (append v1 v2)) === (qreva (qreva v1 (Cons v0 Nil)) v2)
new lemma forall v0: (List a). v0 === (append v0 Nil)
new lemma forall v0: (List a). v1: (List a). (qreva v0 v1) === (qreva (qreva (qreva (append v0 Nil) v1) Nil) Nil)
new lemma forall v0: (List a). v1: (List a). (qreva (append v0 Nil) v1) === (qreva (qreva (qreva v0 v1) Nil) Nil)
new lemma forall v0: (List a). v1: a. v2: (List a). (qreva v0 (Cons v1 v2)) === (qreva (qreva (qreva v0 (Cons v1 v2)) Nil) Nil)
new lemma forall v0: (List a). v1: (List a). (qreva (append v0 Nil) v1) === (qreva (qreva (qreva (append v0 Nil) v1) Nil) Nil)
new lemma forall v0: (List a). v1: (List a). (qreva v0 (qreva v1 Nil)) === (qreva (qreva (qreva v0 (qreva v1 Nil)) Nil) Nil)
new lemma forall v0: (List a). v1: (List a). (qreva v0 v1) === (qreva (qreva (qreva (qreva (qreva v0 Nil) Nil) v1) Nil) Nil)
new lemma forall v0: (List a). v1: (List a). (qreva (qreva (qreva v0 v1) Nil) Nil) === (qreva (qreva (qreva v0 Nil) Nil) v1)
new lemma forall v0: (List a). v1: (List a). v2: (List a). (append v0 (append v1 v2)) === (append (append v0 v1) v2)
prove lemma forall x: (List a). y: (List a). (qreva (qreva x (rev y)) Nil) === (append y x)
clam_82 uncyclic: VALID (13144 ms)
Proving begin clam_83: (rotate (len x) (append x y)) === (append y x)
new lemma forall v0: (List a). v0 === (append v0 Nil)
clam_83 uncyclic: TIMEOUT (60054 ms)
Proving begin clam_84: (mult (fac x) y) === (qfac x y)
clam_84 uncyclic: INVALID (23 ms)
Proving begin clam_85: (plus (mult x y) z) === (qmult x y z)
new lemma forall v0: Nat. v0 === (plus v0 Z)
new lemma forall v0: Nat. v1: Nat. (S (plus v0 v1)) === (plus v0 (S v1))
prove lemma forall v0: Nat. v1: Nat. v2: Nat. (plus v0 (plus v1 v2)) === (plus (plus v0 v2) v1)
prove lemma forall x: Nat. y: Nat. z: Nat. (plus (mult x y) z) === (qmult x y z)
clam_85 uncyclic: VALID (70 ms)
Attempted 49 goals:
  34 solved (no cyclic)

Process finished with exit code 0


